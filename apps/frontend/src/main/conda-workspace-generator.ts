/**
 * Conda Workspace Generator
 *
 * Generates VS Code workspace files and PowerShell init scripts for
 * Conda environment integration. Creates configuration files that allow
 * VS Code to automatically activate the correct Conda environment when
 * opening a terminal.
 *
 * Generated files:
 * - <project-name>.code-workspace: VS Code workspace with Conda terminal profile
 * - scripts/init-<project-name>.ps1: PowerShell init script for environment activation
 */

import { existsSync, promises as fsPromises } from 'fs';
import path from 'path';
import type { VsCodeWorkspaceConfig } from '../shared/types/conda';
import { detectProjectStructure } from './conda-project-structure';

/**
 * Generate VS Code workspace file content
 *
 * Creates a workspace configuration that:
 * - Defines a custom terminal profile for the Conda environment
 * - Sets the default terminal to use the Conda environment
 * - Configures Python extension settings for the environment
 *
 * @param config - Workspace configuration options
 * @returns JSON string of the workspace file content
 */
export async function generateVsCodeWorkspace(
  config: VsCodeWorkspaceConfig
): Promise<string> {
  const { projectName } = config;

  // Build workspace configuration object
  const workspace = {
    folders: [{ path: '.' }],
    settings: {
      'terminal.integrated.profiles.windows': {
        [`${projectName} (Conda)`]: {
          source: 'PowerShell',
          icon: 'terminal-powershell',
          color: 'terminal.ansiGreen',
          args: [
            '-NoLogo',
            '-NoExit',
            '-File',
            `\${workspaceFolder}\\scripts\\init-${projectName}.ps1`,
          ],
        },
      },
      'terminal.integrated.defaultProfile.windows': `${projectName} (Conda)`,
      'python.terminal.activateEnvironment': false,
      'python.defaultInterpreterPath': `\${workspaceFolder}\\.envs\\${projectName}\\python.exe`,
      'python.analysis.typeCheckingMode': 'basic',
      'python.analysis.diagnosticMode': 'workspace',
      'python.analysis.exclude': ['.envs'],
    },
  };

  return JSON.stringify(workspace, null, 2);
}

/**
 * Generate PowerShell init script content
 *
 * Creates a PowerShell script that:
 * - Reads the Conda base path from the environment config
 * - Initializes the Conda shell hook
 * - Activates the project-specific Conda environment
 *
 * @param config - Workspace configuration options
 * @returns PowerShell script content
 */
export async function generatePowerShellInitScript(
  config: VsCodeWorkspaceConfig
): Promise<string> {
  // Note: condaBase is stored in config but the script reads it from .conda_base file
  // at runtime for portability (in case Conda is moved/reinstalled)
  const { projectName } = config;

  const script = `# Auto-generated by Auto Claude - Conda environment activation for ${projectName}
$ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path
$ProjectRoot = Split-Path -Parent $ScriptDir

# Read conda base path from config
$CondaBasePath = Get-Content "$ProjectRoot\\.envs\\${projectName}\\.conda_base" -ErrorAction SilentlyContinue
if (-not $CondaBasePath) {
    $CondaBasePath = "$Env:USERPROFILE\\miniconda3"
}

# Activate conda environment
& "$CondaBasePath\\shell\\condabin\\conda-hook.ps1"
& conda activate "$ProjectRoot\\.envs\\${projectName}"

# Override the prompt to show just the project name instead of full path
$Env:CONDA_PROMPT_MODIFIER = "(${projectName}) "

Write-Host "Activated conda environment: ${projectName}" -ForegroundColor Green
`;

  return script;
}

/**
 * Generate all workspace files (VS Code workspace + PowerShell init script)
 *
 * This is the main entry point for generating workspace configuration files.
 * It uses project structure detection to determine the correct locations
 * for all generated files.
 *
 * @param projectPath - Absolute path to the project root
 * @param projectName - Display name for the project
 * @param condaBase - Path to the Conda installation
 * @returns Object containing paths to generated files
 */
export async function generateWorkspaceFiles(
  projectPath: string,
  projectName: string,
  condaBase: string
): Promise<{ workspacePath: string; initScriptPath: string }> {
  // Detect project structure to determine where files should go
  const structure = detectProjectStructure(projectPath);
  const pythonRoot = structure.pythonRoot;

  // Build configuration object
  const config: VsCodeWorkspaceConfig = {
    projectName,
    pythonRoot,
    envPath: path.join(pythonRoot, '.envs', projectName),
    condaBase,
  };

  // Ensure scripts directory exists
  const scriptsDir = path.join(pythonRoot, 'scripts');
  if (!existsSync(scriptsDir)) {
    console.warn(`[Conda Workspace] Creating scripts directory: ${scriptsDir}`);
    await fsPromises.mkdir(scriptsDir, { recursive: true });
  }

  // Generate VS Code workspace file
  const workspaceContent = await generateVsCodeWorkspace(config);
  const workspacePath = path.join(pythonRoot, `${projectName}.code-workspace`);
  await fsPromises.writeFile(workspacePath, workspaceContent, 'utf-8');
  console.warn(`[Conda Workspace] Generated workspace file: ${workspacePath}`);

  // Generate PowerShell init script
  const initScriptContent = await generatePowerShellInitScript(config);
  const initScriptPath = path.join(scriptsDir, `init-${projectName}.ps1`);
  await fsPromises.writeFile(initScriptPath, initScriptContent, 'utf-8');
  console.warn(`[Conda Workspace] Generated init script: ${initScriptPath}`);

  return { workspacePath, initScriptPath };
}

/**
 * Ensure .gitignore includes .envs/ directory
 *
 * Checks if .gitignore exists and contains an entry for .envs/.
 * If not present, appends the entry to the file. Creates .gitignore
 * if it doesn't exist.
 *
 * @param projectPath - Absolute path to the project root
 */
export async function ensureGitignore(projectPath: string): Promise<void> {
  // Use project structure detection to find the correct root
  const structure = detectProjectStructure(projectPath);
  const gitignorePath = path.join(structure.pythonRoot, '.gitignore');
  const entry = '.envs/';

  try {
    let content = '';

    // Try to read existing .gitignore directly (avoid check-then-act race condition)
    try {
      content = await fsPromises.readFile(gitignorePath, 'utf-8');

      // Check if .envs/ is already in .gitignore
      const lines = content.split(/\r?\n/);
      const hasEnvsEntry = lines.some((line) => {
        const trimmed = line.trim();
        return trimmed === entry || trimmed === '.envs';
      });

      if (hasEnvsEntry) {
        console.warn(
          `[Conda Workspace] .gitignore already contains ${entry}`
        );
        return;
      }

      // Ensure there's a newline at the end before appending
      if (content.length > 0 && !content.endsWith('\n')) {
        content += '\n';
      }
    } catch (readError: unknown) {
      // File doesn't exist, start with empty content
      if (
        readError instanceof Error &&
        'code' in readError &&
        readError.code === 'ENOENT'
      ) {
        content = '';
      } else {
        throw readError;
      }
    }

    // Append .envs/ entry
    content += `${entry}\n`;
    await fsPromises.writeFile(gitignorePath, content, 'utf-8');
    console.warn(`[Conda Workspace] Added ${entry} to .gitignore`);
  } catch (error) {
    console.error(
      `[Conda Workspace] Failed to update .gitignore at ${gitignorePath}:`,
      error
    );
    throw error;
  }
}
